\chapter{Implementazione fisica}

\section{Definizione delle tabelle}
\subsection{\textsc{Utente}}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Utente}]
	CREATE TABLE utente(
	id_utente SERIAL PRIMARY KEY,
	username TEXT NOT NULL UNIQUE,
	nome TEXT NOT NULL,
	cognome TEXT NOT NULL,
	titolo titolo_st,
	email TEXT NOT NULL UNIQUE,
	password TEXT NOT NULL,
	id_ente INTEGER REFERENCES ente(id_ente) ON DELETE CASCADE
	);
\end{lstlisting}
\subsection{\textsc{Ente}}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Ente}]
	CREATE TABLE ente(
	id_ente SERIAL PRIMARY KEY,
	nome TEXT NOT NULL UNIQUE,
	sigla varchar(7) NOT NULL,
	UNIQUE (nome,sigla)
	);
\end{lstlisting}
\subsection{\textsc{Indirizzo}}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Indirizzo}]
CREATE TABLE indirizzo(
id_indirizzo SERIAL PRIMARY KEY,
via TEXT NOT NULL,
civico varchar(5) NOT NULL,
cap varchar(5) ,
city TEXT NOT NULL,
provincia varchar(2) NOT NULL,
nazione TEXT
);
\end{lstlisting}
\subsection{\textsc{Sede}}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella:  Sede}]
CREATE TABLE sede(
id_sede SERIAL PRIMARY KEY,
nome TEXT ,
id_indirizzo INTEGER REFERENCES indirizzo(id_indirizzo) ON DELETE SET NULL
);
\end{lstlisting}
\subsection{\textsc{Sponsor}}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Sponsor}]
CREATE TABLE sponsor(
id_sponsor SERIAL PRIMARY KEY,
nome TEXT NOT NULL
);
\end{lstlisting}
\subsection{\textsc{Comitato}}
Ogni comitato ha una tipologia che varia tra i valori \textit{scientifico} e \textit{locale}. Definiamo quindi il tipo \texttt{comitato\_st} che useremo per specificare la tipologia del comitato:
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Comitato}]
CREATE TYPE comitato_st AS enum ('locale','scientifico');
CREATE TABLE comitato(
id_comitato SERIAL PRIMARY KEY,
tipologia comitato_st NOT NULL
);
\end{lstlisting}
\subsection{\textsc{Organizzatore, Speaker, Partecipante}}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Organizzatore}]
CREATE TYPE titolo_st AS enum ('Dottore','Dottoressa','Professore','Professoressa','Assistente','Ricercatore','Ricercatrice','Ingegnere');

CREATE TABLE organizzatore(
id_organizzatore SERIAL PRIMARY KEY,
nome TEXT NOT NULL,
cognome TEXT NOT NULL,
titolo titolo_st,
email TEXT NOT NULL UNIQUE,
id_ente INTEGER REFERENCES ente(id_ente) ON DELETE CASCADE
);
\end{lstlisting}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Partecipante}]
CREATE TABLE partecipante(
id_partecipante SERIAL PRIMARY KEY,
nome TEXT NOT NULL,
cognome TEXT NOT NULL,
titolo titolo_st,
email TEXT NOT NULL UNIQUE, 
id_ente INTEGER REFERENCES ente(id_ente) ON DELETE SET NULL
);
\end{lstlisting}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Speaker}]
CREATE TABLE speaker(
id_speaker SERIAL PRIMARY KEY,
nome TEXT NOT NULL,
cognome TEXT NOT NULL,
titolo titolo_st,
email TEXT NOT NULL UNIQUE,
id_ente INTEGER REFERENCES ente(id_ente) ON DELETE CASCADE NOT NULL
);
\end{lstlisting}
\subsection{\textsc{Sala}}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Sala}]
	CREATE TABLE sala(
	id_sala SERIAL PRIMARY KEY,
	nome TEXT NOT NULL,
	capienza INTEGER NOT NULL,
	id_sede INTEGER REFERENCES sede(id_sede) ON DELETE CASCADE
	);
\end{lstlisting}
\subsection{\textsc{Conferenza}}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Conferenza}]
CREATE TABLE conferenza(
id_conferenza SERIAL PRIMARY KEY,
titolo TEXT NOT NULL,
descrizione TEXT NOT NULL,
inizio TIMESTAMP NOT NULL,
fine TIMESTAMP NOT NULL,
id_sede INTEGER REFERENCES sede(id_sede) ON DELETE SET NULL,
comitato_s INTEGER REFERENCES comitato(id_comitato) ON DELETE SET NULL,
comitato_l INTEGER REFERENCES comitato(id_comitato) ON DELETE SET NULL,
id_utente INTEGER REFERENCES utente(id_utente) ON DELETE CASCADE,
CHECK (inizio <= fine), 
CHECK (inizio >= now()) 
);
\end{lstlisting}
\subsection{\textsc{Sessione}}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Sessione}]
CREATE TABLE sessione(
id_sessione SERIAL PRIMARY KEY,
titolo TEXT NOT NULL,
inizio TIMESTAMP NOT NULL,
fine TIMESTAMP NOT NULL,
id_coordinatore INTEGER REFERENCES organizzatore(id_organizzatore) ON DELETE SET NULL,
id_conferenza INTEGER REFERENCES conferenza(id_conferenza) ON DELETE CASCADE,
id_sala INTEGER REFERENCES sala(id_sala) ON DELETE SET NULL,
CHECK (inizio <= fine)
);
\end{lstlisting}
\subsection{\textsc{Partecipazione}}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Partecipazione}]
CREATE TABLE partecipazione(
id_partecipante INTEGER REFERENCES partecipante(id_partecipante) ON DELETE CASCADE,
id_sessione INTEGER REFERENCES sessione(id_sessione) ON DELETE CASCADE,
UNIQUE (id_partecipante,id_sessione) 
);
\end{lstlisting}
\subsection{\textsc{Ente\_Conferenza}}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Ente\_Conferenza}]
CREATE TABLE ente_conferenza(
id_ente INTEGER REFERENCES ente(id_ente) ON DELETE CASCADE,
id_conferenza INTEGER REFERENCES conferenza(id_conferenza) ON DELETE CASCADE,
UNIQUE (id_ente,id_conferenza)
);
\end{lstlisting}
\subsection{\textsc{Valuta}}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Valuta}]
CREATE TABLE valuta(
iso CHAR(3) PRIMARY KEY,
nome TEXT NOT NULL,
simbolo TEXT NOT NULL
);
\end{lstlisting}
\subsection{\textsc{Sponsor\_Conferenza}}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Sponsor\_Conferenza}]
CREATE TABLE sponsor_conferenza(
id_sponsor INTEGER REFERENCES sponsor(id_sponsor) ON DELETE CASCADE NOT NULL,
contributo NUMERIC(1000,2) NOT NULL,
valuta CHAR(3) REFERENCES valuta(iso) NOT NULL,
id_conferenza INTEGER REFERENCES conferenza(id_conferenza) ON DELETE CASCADE NOT NULL,
UNIQUE (id_sponsor,id_conferenza) 
);
\end{lstlisting}
\subsection{\textsc{Programma}}
\begin{lstlisting}[language=SQL,style=mystyle,caption={Tabella: Programma}]
CREATE TABLE programma(
id_programma SERIAL PRIMARY KEY,
id_sessione INTEGER REFERENCES sessione(id_sessione) ON DELETE CASCADE NOT NULL,
id_keynote INTEGER REFERENCES speaker(id_speaker) ON DELETE SET NULL,
UNIQUE (id_programma, id_sessione)
);

\end{lstlisting}
\subsection{\textsc{Intervento}}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Intervento}]
CREATE TABLE intervento(
id_intervento SERIAL PRIMARY KEY,
titolo TEXT NOT NULL,
abstract TEXT NOT NULL,
inizio TIMESTAMP NOT NULL,
fine TIMESTAMP NOT NULL,
id_speaker INTEGER REFERENCES speaker(id_speaker) ON DELETE CASCADE,
id_programma INTEGER REFERENCES programma(id_programma) ON DELETE CASCADE NOT NULL,
UNIQUE (id_speaker,id_programma), 
CHECK (inizio <= fine) 
);
\end{lstlisting}
\subsection{\textsc{Intervallo}}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Programma}]
CREATE TYPE intervallo_st AS enum ('pranzo','coffee break');
CREATE TABLE intervallo(
id_intervallo SERIAL PRIMARY KEY,
tipologia intervallo_st NOT NULL,
inizio TIMESTAMP NOT NULL,
fine TIMESTAMP NOT NULL,
CHECK (inizio <= fine), 
id_programma INTEGER REFERENCES programma(id_programma) ON DELETE CASCADE NOT NULL
);
\end{lstlisting}
\subsection{\textsc{Evento}}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Evento}]
CREATE TABLE evento(
id_evento SERIAL PRIMARY KEY,
tipologia TEXT NOT NULL,
inizio TIMESTAMP NOT NULL,
fine TIMESTAMP NOT NULL,
CHECK (inizio <= fine), 
id_programma INTEGER REFERENCES programma(id_programma) ON DELETE CASCADE NOT NULL
);
\end{lstlisting}
\subsection{\textsc{Organizzatore\_Comitato}}
\begin{lstlisting}[language=SQL,style=mystyle, caption={Tabella: Organizzatore\_Comitato}]
CREATE TABLE organizzatore_comitato(
id_organizzatore INTEGER REFERENCES organizzatore(id_organizzatore) ON DELETE CASCADE,
id_comitato INTEGER REFERENCES comitato(id_comitato) ON DELETE CASCADE,
UNIQUE (id_organizzatore,id_comitato) 
);
\end{lstlisting}
\section{Definizione dei trigger}
\subsection{\texttt{Check\_Programma}}
In un programma non devono esserci eventi, intervalli o interventi che si sovrappongono. Per questo motivo definiamo il trigger \texttt{check\_programma\_entry} che viene eseguito per ogni inserimento o aggiornamento nelle tabelle \textsc{Intervento}, \textsc{Intervallo} ed \textsc{Evento}.
\begin{lstlisting}[language=SQL,style=mystyle,caption={check\_programma\_entry}]
CREATE OR REPLACE FUNCTION check_programma() 
RETURNS TRIGGER AS $$
DECLARE
	inizio_evento TIMESTAMP;
	fine_evento TIMESTAMP;
	inizio_intervallo TIMESTAMP;
	fine_intervallo TIMESTAMP;
	inizio_intervento TIMESTAMP;
	fine_intervento TIMESTAMP;
	intervento_id INTEGER;
	intervallo_id INTEGER;
	evento_id INTEGER;
	interventi_cur cursor FOR 
		SELECT id_intervento 
		FROM intervento 
		WHERE id_programma = new.id_programma;
	intervalli_cur cursor FOR 
		SELECT id_intervallo 
		FROM intervallo 
		WHERE id_programma = new.id_programma;
	eventi_cur cursor FOR 
		SELECT id_evento 
		FROM evento 
		WHERE id_programma = new.id_programma;
BEGIN
	OPEN interventi_cur;
	LOOP 
		FETCH interventi_cur INTO intervento_id;
		EXIT WHEN NOT FOUND;
		SELECT inizio,fine INTO inizio_intervento,fine_intervento
		FROM intervento
		WHERE id_intervento = intervento_id;
		IF (new.inizio>=inizio_intervento AND new.fine<=fine_intervento) THEN
			RAISE EXCEPTION 'Impossibile inserire intervento';
		END IF;
	END LOOP;
	CLOSE interventi_cur;
	
	OPEN intervalli_cur;
	LOOP 
		FETCH intervalli_cur INTO intervallo_id;
		EXIT WHEN NOT FOUND;
		SELECT inizio,fine INTO inizio_intervallo,fine_intervallo
		FROM intervallo
		WHERE id_intervallo = intervallo_id;
		IF (new.inizio>=inizio_intervallo AND new.fine<=fine_intervallo) THEN
			RAISE EXCEPTION 'Impossibile inserire intervallo';
		END IF;
		END LOOP;
	CLOSE intervalli_cur;
	
	OPEN eventi_cur;
	LOOP 
		FETCH eventi_cur INTO evento_id;
		EXIT WHEN NOT FOUND;
		SELECT inizio,fine INTO inizio_evento,fine_evento
		FROM evento
		WHERE id_evento = evento_id;
		IF (new.inizio>=inizio_evento AND new.fine<=fine_evento) THEN
			RAISE EXCEPTION 'Impossibile inserire evento';
		END IF;
	END LOOP;
	CLOSE eventi_cur;
	RETURN NEW;
END;
$$ 
LANGUAGE PLPGSQL;

CREATE TRIGGER check_programma
BEFORE INSERT OR UPDATE ON intervento
FOR EACH ROW
EXECUTE FUNCTION check_programma();

CREATE TRIGGER check_programma
BEFORE INSERT OR UPDATE ON intervallo
FOR EACH ROW
EXECUTE FUNCTION check_programma();

CREATE TRIGGER check_programma
BEFORE INSERT OR UPDATE ON evento
FOR EACH ROW
EXECUTE FUNCTION check_programma();
\end{lstlisting}

\subsection{\texttt{Check\_Data\_Intervento, Check\_Data\_Intervallo, Check\_Data\_Evento}}\label{trigger:check_data}
Ogni volta che viene inserito o aggiornato un intervento, un intervallo o un evento bisogna controllare sempre che la data di inizio e di fine sia coerente con quella della sessione cui appartengono:
\begin{lstlisting}[caption={check\_data\_intervento},language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION check_data() RETURNS TRIGGER AS $$
DECLARE
inizio_sessione TIMESTAMP;
fine_sessione TIMESTAMP;
BEGIN
SELECT inizio,fine INTO inizio_sessione,fine_sessione
FROM sessione
WHERE id_sessione = (SELECT id_sessione FROM programma WHERE id_programma = new.id_programma);

IF (new.inizio < inizio_sessione OR new.fine > fine_sessione) THEN
RAISE EXCEPTION 'L''intervento non e'' compreso nella sessione';
END IF;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER check_data_evento
BEFORE INSERT OR UPDATE ON evento
FOR EACH ROW
EXECUTE FUNCTION check_data();

CREATE TRIGGER check_data_intervento
BEFORE INSERT OR UPDATE ON intervento
FOR EACH ROW
EXECUTE FUNCTION check_data();

CREATE TRIGGER check_data_intervallo
BEFORE INSERT OR UPDATE ON intervallo
FOR EACH ROW
EXECUTE FUNCTION check_data();
\end{lstlisting}
\subsection{\texttt{Create\_Programma\_Sessione}}
Il trigger \texttt{Create\_Programma\_Sessione} viene attivato subito dopo aver inserito una nuova sessione ed effettua l'inserimento di un programma vuoto associato alla sessione.
\begin{lstlisting}[language=SQL, caption={\texttt{create\_programma\_sessione}},style=mystyle]
CREATE OR REPLACE FUNCTION create_programma_sessione() RETURNS TRIGGER AS $$
BEGIN
INSERT INTO programma(id_sessione) VALUES (new.id_sessione);
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER create_programma_sessione
AFTER INSERT ON sessione
FOR EACH ROW
EXECUTE FUNCTION create_programma_sessione();
\end{lstlisting}
\subsection{\texttt{Check\_Sala\_Sessione}}
Quando inseriamo una sessione bisogna stare attenti che la chiave esterna della sala sia effettivamente una sala appartenente alla sede che ospita la conferenza della sessione IN questione. Il trigger \texttt{check\_sala\_sessione} effettua quindi questo controllo prima di ciascun inserimento nella tabella \textsc{Sessione}:
\begin{lstlisting}[language=SQL, style=mystyle]
CREATE OR REPLACE FUNCTION check_sala_sessione() RETURNS TRIGGER AS $$
DECLARE
sede INTEGER;
sala INTEGER;
BEGIN
SELECT id_sede INTO sede
FROM conferenza
WHERE id_conferenza = new.id_conferenza;

SELECT id_sala INTO sala
FROM sala
WHERE id_sala = new.id_sala;

IF sala IS NULL THEN
Return new;
END IF;

IF sala NOT IN (
SELECT id_sala
FROM sala
WHERE id_sede = sede
) THEN
RAISE EXCEPTION 'La sala selezionata non appartiene alla sede della conferenza';
END IF;

RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;


CREATE TRIGGER check_sala_sessione
BEFORE INSERT OR UPDATE ON sessione
FOR EACH ROW
EXECUTE FUNCTION check_sala_sessione();
\end{lstlisting}
\subsection{\texttt{Check\_Data\_Sessione}}
Analogamente ai trigger \ref{trigger:check_data} si definisce il trigger \texttt{check\_data\_sessione} che controlla che le DATE di inizio e di fine di ciascuna sessione siano coerenti con quelle della relativa conferenza:
\begin{lstlisting}[language=SQL, style=mystyle, caption={\texttt{check\_data\_sessione}}]
CREATE OR REPLACE FUNCTION check_data_sessione() RETURNS TRIGGER AS $$
DECLARE
inizio_conferenza TIMESTAMP;
fine_conferenza TIMESTAMP;
BEGIN
SELECT inizio, fine INTO inizio_conferenza,fine_conferenza
FROM conferenza
WHERE id_conferenza = new.id_conferenza;

IF (new.inizio < inizio_conferenza OR new.fine > fine_conferenza) THEN
RAISE EXCEPTION 'La sessione non e'' compresa nella conferenza';
END IF;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER check_data_sessione
BEFORE INSERT OR UPDATE ON sessione
FOR EACH ROW
EXECUTE FUNCTION check_data_sessione();
\end{lstlisting}
\subsection{\texttt{Check\_Coordinatore\_Sessione}}
Quando si specifica il coordinatore della sessione bisogna controllare che questi appartenga al comitato scientifico che è il gruppo di organizzatori che si occupano della gestione delle conferenze e delle sessioni:
\begin{lstlisting}[caption={check\_coordinatore\_sessione}, language=sql, style=mystyle]
CREATE OR REPLACE FUNCTION check_coordinatore_sessione() RETURNS TRIGGER AS $$
DECLARE 
id_comitato_scientifico_conferenza INTEGER;
BEGIN

SELECT comitato_s INTO id_comitato_scientifico_conferenza
FROM conferenza c
WHERE c.id_conferenza = new.id_conferenza;

IF (new.id_coordinatore is NOT NULL) THEN
IF (id_comitato_scientifico_conferenza NOT IN (SELECT id_comitato FROM organizzatore_comitato WHERE id_organizzatore = new.id_coordinatore))  THEN
RAISE EXCEPTION 'Il coordinatore della sessione deve appartenere al comitato scientifico della conferenza';
END IF;
END IF;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER check_coordinatore_sessione
BEFORE INSERT OR UPDATE ON sessione
FOR EACH ROW
EXECUTE FUNCTION check_coordinatore_sessione();

\end{lstlisting}
\subsection{\texttt{Create\_Comitati\_Conferenza}}
Gli enti che organizzano le conferenze nominano due comitati per ogni conferenza che organizzano. Per questo motivo, ogni volta che viene inserita una nuova conferenza viene attivato il trigger \texttt{create\_comitati\_conferenza} che si occupa di creare due nuovi comitati di tipologica \textit{scientifica} e \textit{locale} e associarli alla nuova conferenza appena create:
\begin{lstlisting}[language=SQL, style=mystyle, caption={\texttt{create\_comitati\_conferenza}}]
CREATE OR REPLACE FUNCTION create_comitati_conferenza() RETURNS TRIGGER AS $$
DECLARE 
id_comitatoscientifico INTEGER;
id_comitatolocale INTEGER;
BEGIN
INSERT INTO comitato(tipologia) VALUES ('scientifico') returning id_comitato INTO id_comitatoscientifico;
INSERT INTO comitato(tipologia) VALUES ('locale') returning id_comitato INTO id_comitatolocale;
UPDATE conferenza SET comitato_s = id_comitatoscientifico, comitato_l = id_comitatolocale WHERE id_conferenza = new.id_conferenza;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER create_comitati_conferenza
AFTER INSERT ON conferenza
FOR EACH ROW
EXECUTE FUNCTION create_comitati_conferenza();
\end{lstlisting}
\subsection{\texttt{Check\_Comitati\_Conferenza}}
Ogni volta che si aggiorna una conferenza bisogna controllare che le chiavi esterne dei due comitati si riferiscano sempre a comitati della tipologia richiesta:
\begin{lstlisting}[language=SQL, caption={\texttt{check\_comitati\_conferenza}},style=mystyle]
CREATE OR REPLACE FUNCTION check_comitati_conferenza() RETURNS TRIGGER AS $$
DECLARE 
id_comitato_scientifico INTEGER;
id_comitato_locale INTEGER;
BEGIN
SELECT id_comitato INTO id_comitato_scientifico
FROM comitato
WHERE id_comitato = new.comitato_s;

SELECT id_comitato INTO id_comitato_locale
FROM comitato
WHERE id_comitato = new.comitato_l;

IF id_comitato_scientifico IS NULL THEN
RETURN NEW;
END IF;

IF id_comitato_locale IS NULL THEN
RETURN NEW;
END IF;

IF (SELECT tipologia FROM comitato WHERE id_comitato = id_comitato_scientifico) <> 'scientifico' THEN
RAISE EXCEPTION 'Il comitato scientifico deve essere scientifico';
END IF;

IF (SELECT tipologia FROM comitato WHERE id_comitato = id_comitato_locale) <> 'locale' THEN
RAISE EXCEPTION 'Il comitato locale deve essere locale';
END IF;

RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER check_comitati_conferenza
BEFORE UPDATE ON conferenza
FOR EACH ROW
EXECUTE FUNCTION check_comitati_conferenza();
\end{lstlisting}
\subsection{\texttt{Check\_Sala\_Sessione\_Unica}}
Una sala non può ospitare più di una sessione alla volta.
\begin{lstlisting}[caption={\texttt{Check\_sala\_sessione\_unica}}, language=SQL, style=mystyle]
CREATE OR REPLACE FUNCTION check_sala_sessione_unica() RETURNS TRIGGER AS $$
DECLARE
inizio_sessione TIMESTAMP;
fine_sessione TIMESTAMP;
sessioni cursor FOR SELECT id_sessione FROM sessione WHERE id_sala = new.id_sala;
sessione_id INTEGER;
BEGIN
OPEN sessioni;
LOOP
FETCH sessioni INTO sessione_id;
EXIT WHEN NOT FOUND;
SELECT inizio,fine INTO inizio_sessione,fine_sessione
FROM sessione
WHERE id_sessione = sessione_id;
IF (new.inizio >= inizio_sessione AND new.inizio <= fine_sessione) OR (new.fine >= inizio_sessione AND new.fine <= fine_sessione) THEN
RAISE EXCEPTION 'La sala non puo'' ospitare piu'' di una sessione alla volta';
END IF;
END LOOP;
CLOSE sessioni;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER check_sala_sessione_unica
BEFORE INSERT OR UPDATE ON sessione
FOR EACH ROW
EXECUTE FUNCTION check_sala_sessione_unica();
\end{lstlisting}
\subsection{\texttt{Check\_Organizzatore\_Comitato}}
Ogni volta che si inserisce un nuovo organizzatore all'interno di un comitato bisogna controllare che questo appartenga ad uno degli enti che organizzano la conferenza.
\begin{lstlisting}[language=SQL, style=mystyle, caption={\texttt{Check\_organizzatori\_comitato}}]
CREATE OR REPLACE FUNCTION check_organizzatore_comitato() RETURNS TRIGGER AS $$
DECLARE
ente_id INTEGER;
BEGIN

SELECT id_ente INTO ente_id
FROM organizzatore o
WHERE o.id_organizzatore = new.id_organizzatore;

IF ente_id IS NULL THEN
RAISE EXCEPTION 'L''organizzatore non esiste';
END IF;

IF ente_id NOT IN (
SELECT id_ente
FROM ente_conferenza
WHERE id_conferenza IN (
SELECT id_conferenza
FROM conferenza
WHERE NEW.id_comitato IN (id_comitato_scientifico, id_comitato_locale)
)
) THEN
RAISE EXCEPTION 'L''organizzatore deve appartenere ad un ente che ha organizzato la conferenza';
END IF;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER check_organizzatore_comitato
BEFORE INSERT OR UPDATE ON organizzatore_comitato
FOR EACH ROW
EXECUTE FUNCTION check_organizzatore_comitato();
\end{lstlisting}
\subsection{\texttt{Delete\_Sessioni\_Conferenza}}
Nel caso IN cui si volesse modificare la data di inizio o di fine di una conferenza vengono automaticamente cancellate le sessioni che si trovano escluse dal nuovo intervallo di DATE.
\begin{lstlisting}[language=SQL, style=mystyle, caption={\texttt{DELETE\_sessioni\_conferenza}}]
CREATE OR REPLACE FUNCTION delete_sessioni_conferenza() RETURNS TRIGGER AS $$
DECLARE
sessioni_cur cursor FOR 
SELECT id_sessione 
FROM sessione 
WHERE id_conferenza = old.id_conferenza;
sessione_id INTEGER;
BEGIN
OPEN sessioni_cur;
LOOP
FETCH sessioni_cur INTO sessione_id;
EXIT WHEN NOT FOUND;
IF (SELECT inizio FROM sessione WHERE id_sessione = sessione_id) < new.inizio 
OR (SELECT fine FROM sessione WHERE id_sessione = sessione_id) > new.fine THEN
DELETE FROM sessione WHERE id_sessione = sessione_id;
END IF;
END LOOP;
CLOSE sessioni_cur;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER delete_sessioni_conferenza
BEFORE UPDATE ON conferenza
FOR EACH ROW
EXECUTE FUNCTION delete_sessioni_conferenza();
\end{lstlisting}
\subsection{\texttt{Check\_Capienza}}
Ogni volta che si aggiunge un nuovo partecipante della sessione bisogna controllare prima che la capienza della sala dove si svolge la sessione non sia stata raggiunta:
\begin{lstlisting}[language=SQL, style=mystyle]
CREATE OR REPLACE FUNCTION check_capienza_sala() RETURNS TRIGGER AS $$
DECLARE
capienza_s INTEGER;
partecipanti INTEGER;
BEGIN
SELECT capienza INTO capienza_s
FROM sala
WHERE id_sala = new.id_sala;

SELECT count(*) INTO partecipanti
FROM partecipazione
WHERE id_sessione = new.id_sessione;

IF (partecipanti >= capienza_s) THEN
RAISE EXCEPTION 'La capienza della sala e'' stata raggiunta';
END IF;
RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER check_capienza_sala
before insert ON partecipazione
FOR EACH ROW
EXECUTE FUNCTION check_capienza_sala();
\end{lstlisting}
\section{Funzioni e procedure}
\subsection{\texttt{Show\_Conferenze\_By\_Date(DATE,DATE)}}
La funzione \texttt{Show\_Conferenze\_By\_Date} prende IN ingresso due DATE e restituisce l'insieme di tutte le conferenze comprese tra queste:
\begin{lstlisting}[language=SQL, style=mystyle]
CREATE OR REPLACE FUNCTION show_conference_by_date(dataI DATE, dataF DATE)
RETURNS SETOF conferenza AS $$
BEGIN
RETURN QUERY
SELECT * FROM conferenza
WHERE inizio >= dataI AND fine <= dataF;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_Conferenze\_By\_Sede(integer)}}
La funzione \texttt{Show\_Conferenze\_By\_Sede} prende IN ingresso la chiave primaria di una sede e restituisce l'insieme di tutte le conferenze ospitate IN quella determinata sede:
\begin{lstlisting}[language=SQL, style=mystyle]
CREATE OR REPLACE FUNCTION show_conferences_by_sede(sede INTEGER)
RETURNS SETOF conferenza AS $$
BEGIN
RETURN QUERY
SELECT * FROM conferenza
WHERE id_sede = sede;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_comitato\_scientifico(integer)}}
La funzione \texttt{Show\_comitato\_scientifico} prende IN ingresso la chiave primaria di una conferenza e restituisce la lista di tutti i membri organizzatori appartenenti al comitato scientifico della conferenza:
\begin{lstlisting}[language=SQL, style=mystyle]
CREATE OR REPLACE FUNCTION show_comitato_scientifico(conferenza INTEGER)
RETURNS SETOF organizzatore AS $$
BEGIN
RETURN QUERY
-- Select dei dettagli dell'organizzatore
SELECT * FROM organizzatore
WHERE id_organizzatore IN (
-- Select degli id degli organizzatori appartenenti al comitato scientifico
SELECT id_organizzatore FROM organizzatore_comitato
WHERE id_comitato = (
-- Select dell'id del comitato scientifico della conferenza
SELECT id_comitato_scientifico FROM conferenza
WHERE id_conferenza = conferenza
)
);
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_comitato\_locale(integer)}}
La funzione \texttt{Show\_comitato\_locale} prende IN ingresso la chiave primaria di una conferenza e restituisce la lista di tutti i membri organizzatori appartenenti al comitato locale della conferenza:
\begin{lstlisting}[language=SQL, style=mystyle]
CREATE OR REPLACE FUNCTION show_comitato_locale(conferenza INTEGER)
RETURNS SETOF organizzatore AS $$
BEGIN
RETURN QUERY
-- Select dei dettagli dell'organizzatore
SELECT * FROM organizzatore
WHERE id_organizzatore IN (
-- Select degli id degli organizzatori appartenenti al comitato locale
SELECT id_organizzatore FROM organizzatore_comitato
WHERE id_comitato = (
-- Select dell'id del comitato locale della conferenza
SELECT id_comitato_locale FROM conferenza
WHERE id_conferenza = conferenza
)
);
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_Partecipanti(INTEGER)}}
La funzione \texttt{Show\_Partecipanti} prende IN ingresso la chiave primaria di una conferenza e restituisce tutti i dettagli dei partecipanti di \textit{tutte le sessioni} della conferenza.
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION show_partecipanti(conferenza INTEGER)
RETURNS SETOF partecipante AS $$
BEGIN
RETURN QUERY
-- Select dei dettagli del partecipante
SELECT * FROM partecipante
WHERE id_partecipante IN (
-- Select degli id dei partecipanti
SELECT id_partecipante FROM partecipazione
WHERE id_sessione IN (
-- Select degli id delle sessioni della conferenza
SELECT id_sessione FROM sessione
WHERE id_conferenza = conferenza
)
);
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_Sessioni(integer)}}
La funzione \texttt{show\_sessioni} prende IN ingresso la chiave primaria di una conferenza e restituisce tutti i dettagli delle sessioni.
\begin{lstlisting}[language=SQL, style=mystyle]
CREATE OR REPLACE FUNCTION show_sessioni(conferenza INTEGER)
RETURNS SETOF sessione AS $$
BEGIN
RETURN QUERY
SELECT * FROM sessione
WHERE id_conferenza = conferenza
order by inizio;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_interventi\_sessione(integer)}}
La funzione \texttt{show\_interventi\_sessione} prende IN ingresso la chiave primaria di una sessione e mostra tutti gli interventi presenti nel programma di tale sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION show_interventi_sessione(sessione INTEGER)
RETURNS TABLE
(
titolo TEXT,
inizio TIMESTAMP,
fine TIMESTAMP,
abstract TEXT,
speaker TEXT
)  AS $$
DECLARE 
programma INTEGER;
BEGIN
SELECT id_programma INTO programma
FROM programma
WHERE id_sessione = sessione;

SELECT titolo,inizio,fine,abstract, s.nome || ' ' || s.cognome AS speaker
FROM intervento i JOIN speaker s ON i.id_speaker = s.id_speaker
WHERE i.id_programma = programma
order by inizio;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}

\subsection{\texttt{Show\_intervalli\_sessione(integer)}}
La funzione \texttt{show\_intervalli\_sessione} prende IN ingresso la chiave primaria di una sessione e mostra tutti gli intervalli presenti nel programma di tale sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION show_intervalli_sessione(sessione INTEGER)
RETURNS TABLE
(
id_intervallo INTEGER,
tipologia intervallo_st,
inizio TIMESTAMP,
fine TIMESTAMP
)  
AS $$
DECLARE 
programma INTEGER;
BEGIN
SELECT id_programma INTO programma
FROM programma
WHERE id_sessione = sessione;

SELECT id_intervallo,tipologia,inizio,fine
FROM intervallo i
WHERE id_programma = programma
order by inizio;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_eventi\_sociali\_sessione(integer)}}
La funzione \texttt{show\_eventi\_sociali\_sessione} prende IN ingresso la chiave primaria di una sessione e mostra tutti gli intervalli presenti nel programma di tale sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION show_eventi_sociali_sessione(sessione INTEGER)
RETURNS TABLE
(
id_evento INTEGER,
tipologia TEXT,
inizio TIMESTAMP,
fine TIMESTAMP) 
AS $$
DECLARE 
programma INTEGER;
BEGIN
SELECT id_programma INTO programma
FROM programma
WHERE id_sessione = sessione;

SELECT id_evento,tipologia,inizio,fine
FROM evento
WHERE id_programma = programma
order by inizio;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_keynote\_sessione(integer)}}
La funzione \texttt{show\_keynote\_sessione} prende IN ingresso la chiave primaria di una sessione e mostra i dettagli del keynote speaker, se presente:
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION show_keynote_sessione(sessione INTEGER)
RETURNS TABLE(
id_speaker INTEGER,
nome TEXT,
cognome TEXT,
titolo TEXT,
email TEXT,
ente TEXT) 
AS $$
DECLARE 
programma INTEGER;
BEGIN
SELECT id_programma INTO programma
FROM programma
WHERE id_sessione = sessione;

SELECT s.id_speaker,s.nome,s.cognome,s.titolo,s.email,e.nome
FROM speaker s JOIN ente e ON s.id_ente = e.id_ente
WHERE s.id_speaker = (
SELECT id_keynote
FROM programma
WHERE id_programma = programma
);
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_Programma(integer)}}
La funzione \texttt{Show\_Programma} prende IN ingresso la chiave primaria di una sessione e restituisce una tabella che mostra tutti gli appuntamenti IN progamma IN ordine cronologico:
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION show_programma(sessione INTEGER)
RETURNS TABLE (
id_entry INTEGER,
appuntamento TEXT,
inizio TIMESTAMP,
fine TIMESTAMP,
descrizione TEXT,
speaker TEXT
)
AS $$
DECLARE
programma INTEGER;
BEGIN
SELECT id_programma INTO programma
FROM programma
WHERE id_sessione = sessione;

RETURN QUERY
SELECT *
FROM (
SELECT distinct i.id_intervento AS id_entry,
'intervento' AS appuntamento,
i.inizio,
i.fine,
i.abstract,
s.nome || ' ' || s.cognome AS speaker
FROM intervento i
JOIN speaker s ON i.id_speaker = s.id_speaker
WHERE i.id_programma = programma

UNION ALL

SELECT i2.id_intervallo AS id_entry,
'intervallo' AS appuntamento,
i2.inizio,
i2.fine,
tipologia::TEXT AS descrizione,
NULL
FROM intervallo i2
WHERE i2.id_programma = programma

UNION ALL

SELECT e.id_evento AS id_entry,
'evento' AS appuntamento,
e.inizio,
e.fine,
e.tipologia::TEXT AS descrizione,
NULL
FROM evento e
WHERE e.id_programma = programma
) AS subquery
ORDER BY inizio;
END;
$$ LANGUAGE plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Intervento(TEXT,TEXT,TEXT,INTEGER,interval)}}
La procedura \texttt{Add\_intervento} provvede all'inserimento di un intervento all'interno del programma della sessione. Questa calcola l'orario esatto IN cui inserire il nuovo punto sulla base dell'ultimo punto IN programma. Se non esistono punti IN programma allora l'ora di inizio è calcolato come l'inizio della sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace procedure add_intervento
(titolo TEXT, 
abstract TEXT, 
speaker TEXT, 
sessione_id INTEGER,
durata interval)
AS $$
DECLARE
programma INTEGER;
fine_prev TIMESTAMP;
BEGIN
SELECT id_programma INTO programma
FROM programma
WHERE id_sessione = sessione_id;

SELECT max(fine) INTO fine_prev
FROM show_programma(sessione_id);

IF (fine_prev is NULL) THEN
SELECT inizio INTO fine_prev
FROM sessione
WHERE id_sessione = sessione_id;
END IF;

INSERT INTO intervento(titolo,abstract,id_speaker,id_programma,inizio,fine)
VALUES (titolo,abstract,speaker,programma,fine_prev,fine_prev+durata);
RAISE NOTICE 'Inserimento completato';
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '%', SQLERRM;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Add\_Intervallo(TEXT,INTEGER,interval)}}
La procedura \texttt{Add\_Intervallo} provvede all'inserimento di un intervallo all'interno del programma della sessione. Questa calcola l'orario esatto IN cui inserire il nuovo punto sulla base dell'ultimo punto IN programma. Se non esistono punti IN programma allora l'ora di inizio è calcolato come l'inizio della sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace procedure 
add_intervallo(tipologia TEXT , sessione_id INTEGER, durata interval)
AS $$
DECLARE
programma INTEGER;
fine_prev TIMESTAMP;
BEGIN
SELECT id_programma INTO programma
FROM programma
WHERE id_sessione = sessione_id;

SELECT max(fine) INTO fine_prev
FROM show_programma(sessione_id);

IF (fine_prev is NULL) THEN
SELECT inizio INTO fine_prev
FROM sessione
WHERE id_sessione = sessione_id;
END IF;

INSERT INTO intervallo(tipologia,id_programma,inizio,fine)
VALUES (tipologia::intervallo_st, programma, fine_prev, fine_prev+durata);
RAISE NOTICE 'Inserimento completato';
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '%', SQLERRM;
END;
$$ 
LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Add\_Evento(TEXT,INTEGER,interval)}}
La procedura \texttt{Add\_Evento} provvede all'inserimento di un evento all'interno del programma della sessione. Questa calcola l'orario esatto IN cui inserire il nuovo punto sulla base dell'ultimo punto IN programma. Se non esistono punti IN programma allora l'ora di inizio è calcolato come l'inizio della sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace procedure 
add_evento
(tipologia TEXT, 
sessione_id INTEGER, 
durata interval)
AS $$
DECLARE
programma_id INTEGER;
fine_prev TIMESTAMP;
BEGIN
-- Recupera l'id del programma della sessione
SELECT id_programma INTO programma_id
FROM programma
WHERE id_sessione = sessione_id;

-- Recupera l'id dell'ultimo punto IN programma, la tipologia e la fine
SELECT max(fine) INTO fine_prev
FROM show_programma(sessione_id);

IF (fine_prev is NULL) THEN
SELECT inizio INTO fine_prev
FROM sessione
WHERE id_sessione = sessione_id;
END IF;

INSERT INTO evento(tipologia, id_programma, inizio, fine)
VALUES (tipologia, programma_id, fine_prev, fine_prev+durata);
RAISE NOTICE 'Inserimento completato';
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '%', SQLERRM;
END;
$$
LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Add\_Conferenza\_Details(TEXT,TIMESTAMP,TIMESTAMP,integer,TEXT)}}
La funzione \texttt{Add\_Conferenza\_Details} aggiunge una conferenza e restituisce la chiave primaria della nuova conferenza.
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION add_conferenza_details
(nome TEXT, inizio TIMESTAMP, fine TIMESTAMP, sede INTEGER, abstract TEXT, utente INTEGER)
RETURNS INTEGER AS $$
DECLARE
id INTEGER;
BEGIN
INSERT INTO conferenza(titolo, inizio, fine, id_sede, descrizione, id_utente) 
VALUES (nome, inizio, fine, sede, abstract,utente)
RETURNING id_conferenza INTO id;
RAISE NOTICE 'Inserimento completato';
RETURN id;
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE 'Errore nell''inserimento di una conferenza: %', SQLERRM;
RETURN 0; 
END;
$$ LANGUAGE plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_ente(integer, integer)}}
La procedura \texttt{Add\_ente} provvede all'inserimento di una nuova istituzione tra gli organizzatori di una conferenza.
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace procedure add_ente(ente INTEGER, conferenza INTEGER)
AS $$
BEGIN
INSERT INTO ente_conferenza(id_ente,id_conferenza)
VALUES (ente,conferenza);
RAISE NOTICE 'Inserimento completato';
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '%', SQLERRM;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Add\_Sponsorizzazione(integer,NUMERIC,CHAR(3),integer)}}
La procedura \texttt{Add\_Sponsorizzazione} inserisce una nuova sponsorizzazione per la conferenza:
\begin{lstlisting}[language=SQL, style=mystyle]
create or replace procedure add_sponsorizzazione(sponsor INTEGER, contributo NUMERIC(1000,2), valuta CHAR(3), conferenza INTEGER)
AS $$
BEGIN
INSERT INTO sponsorizzazione(id_sponsor,contributo,valuta,id_conferenza)
VALUES (sponsor,contributo,valuta,conferenza);
RAISE NOTICE 'Inserimento completato';
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '%', SQLERRM;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Add\_Sessione(TEXT,TIMESTAMP,TIMESTAMP, integer,integer)}}
La procedura \texttt{Add\_Sessione} aggiunge una nuova sessione per la conferenza:
\begin{lstlisting}[language=SQL, style=mystyle]
create or replace procedure add_sessione(titolo TEXT, inizio TIMESTAMP, fine TIMESTAMP, sala INTEGER, conferenza INTEGER)
AS $$
BEGIN
INSERT INTO sessione(titolo,inizio,fine,id_sala,id_conferenza)
VALUES (titolo,inizio,fine,sala,conferenza);
RAISE NOTICE 'Inserimento completato';
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '%', SQLERRM;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Add\_Partecipante(integer, integer)}}
La procedura \texttt{Add\_Partecipante} inserisce un nuovo partecipante alla sessione:
\begin{lstlisting}[language=SQL, style=mystyle]
create or replace procedure add_partecipante(partecipante INTEGER, sessione INTEGER)
AS $$
BEGIN
INSERT INTO partecipante_sessione(id_partecipante,id_sessione)
VALUES (partecipante,sessione);
RAISE NOTICE 'Inserimento completato';
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '%', SQLERRM;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Add\_Enti(integer,TEXT)}}
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE PROCEDURE add_enti(conferenza INTEGER, sigle TEXT)
AS $$
DECLARE
sigla_ente TEXT;
ente_id INTEGER;
BEGIN
FOR sigla_ente IN SELECT unnest(string_to_array(sigle, ',')) LOOP
-- Cerca l'id dell'ente corrispondente alla sigla
SELECT id_ente INTO ente_id FROM ente WHERE sigla = sigla_ente;

-- Inserisci la tupla (id_ente, conferenza) nella tabella ente_conferenza
INSERT INTO ente_conferenza(id_ente, id_conferenza) VALUES (ente_id, conferenza);
END LOOP;
RAISE NOTICE 'Inserimento completato';
EXCEPTION
WHEN OTHERS THEN
RAISE EXCEPTION 'Errore durante l''inserimento delle tuple nella tabella ente_conferenza: %', SQLERRM;
END;
$$ LANGUAGE plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Conferenza(TEXT,TIMESTAMP,TIMESTAMP,integer, TEXT, TEXT)}}
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace procedure add_conferenza(nome TEXT, inizio TIMESTAMP, fine TIMESTAMP, sede INTEGER, descrizione TEXT, sigle TEXT)
AS $$
DECLARE
id_conferenza INTEGER;
BEGIN
id_conferenza := add_conferenza_details(nome,inizio,fine,sede,descrizione);
call add_enti(id_conferenza,sigle);
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '%', SQLERRM;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Slitta\_Conferenza(interval)}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace procedure 
slitta_conferenza(conferenza_id INTEGER, durata interval)
AS $$
DECLARE
sessione_id INTEGER;
intervento_id INTEGER;
evento_id INTEGER;
intervallo_id INTEGER;
sessioni cursor FOR 
SELECT id_sessione 
FROM sessione 
WHERE id_conferenza = conferenza_id;

interventi cursor FOR
SELECT id_intervento 
FROM intervento i JOIN programma p 
ON i.id_programma = p.id_programma 
WHERE p.id_sessione IN 
(SELECT id_sessione 
FROM sessione 
WHERE id_conferenza = conferenza_id);

intervalli cursor FOR
SELECT id_intervallo 
FROM intervallo i JOIN programma p 
ON i.id_programma = p.id_programma 
WHERE p.id_sessione IN 
(SELECT id_sessione 
FROM sessione 
WHERE id_conferenza = conferenza_id);

eventi cursor FOR
SELECT id_evento 
FROM evento e JOIN programma p 
ON e.id_programma = p.id_programma 
WHERE p.id_sessione IN 
(SELECT id_sessione 
FROM sessione 
WHERE id_conferenza = conferenza_id);
BEGIN
ALTER TABLE conferenza DISABLE TRIGGER ALL;
ALTER TABLE sessione DISABLE TRIGGER ALL;
ALTER TABLE intervento DISABLE TRIGGER ALL;
ALTER TABLE intervallo DISABLE TRIGGER ALL;
ALTER TABLE evento DISABLE TRIGGER ALL;
ALTER TABLE programma DISABLE TRIGGER ALL;
UPDATE conferenza
SET inizio = inizio + durata, fine = fine + durata
WHERE id_conferenza = conferenza_id;

OPEN sessioni;
LOOP
FETCH sessioni INTO sessione_id;
EXIT WHEN NOT FOUND;

UPDATE sessione
SET inizio = inizio + durata, fine = fine + durata
WHERE id_sessione = sessione_id;

OPEN interventi;
LOOP
FETCH interventi INTO intervento_id;
EXIT WHEN NOT FOUND;

UPDATE intervento
SET inizio = inizio + durata, fine = fine + durata
WHERE id_intervento = intervento_id ;
END LOOP;
CLOSE interventi;

OPEN intervalli;
LOOP
FETCH intervalli INTO intervallo_id;
EXIT WHEN NOT FOUND;

UPDATE intervallo
SET inizio = inizio + durata, fine = fine + durata
WHERE id_intervallo = intervallo_id;
END LOOP;
CLOSE intervalli;

OPEN eventi;
LOOP
FETCH eventi INTO evento_id;
EXIT WHEN NOT FOUND;

UPDATE evento
SET inizio = inizio + durata, fine = fine + durata
WHERE id_evento = evento_id;
END LOOP;
CLOSE eventi;
END LOOP;
CLOSE sessioni;
ALTER TABLE conferenza ENABLE TRIGGER ALL;
ALTER TABLE sessione ENABLE TRIGGER ALL;
ALTER TABLE intervento ENABLE TRIGGER ALL;
ALTER TABLE intervallo ENABLE TRIGGER ALL;
ALTER TABLE evento ENABLE TRIGGER ALL;
ALTER TABLE programma ENABLE TRIGGER ALL;
RAISE NOTICE 'Slittamento completato';
EXCEPTION
WHEN OTHERS THEN
RAISE NOTICE '%', SQLERRM;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}

\subsection{\texttt{Show\_members()}}
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION show_members(conferenza INTEGER)
RETURNS TABLE 
(
id INTEGER, 
nome TEXT, 
cognome TEXT, 
email TEXT,
titolo titolo_st, 
sigla varchar(7)
) 
AS $$
BEGIN
RETURN QUERY
SELECT o.id_organizzatore, o.nome, o.cognome, o.email,o.titolo, e.sigla
FROM organizzatore o JOIN ente_conferenza ec natural JOIN ente e  
ON o.id_ente = ec.id_ente
WHERE ec.id_conferenza = conferenza
GROUP by e.sigla;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_percentage\_interventi}(INTEGER,INTEGER)}
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION show_percentage_interventi(mese INTEGER, anno INTEGER)
RETURNS TABLE
(
ente TEXT,
percentuale TEXT
) AS $$
DECLARE
totale INTEGER;
BEGIN
SELECT count(*) INTO totale
FROM intervento
WHERE date_part('month',inizio) = mese AND date_part('year',inizio) = anno;

RETURN QUERY
SELECT e.nome, (count(*)*100/totale)::TEXT || '%'
FROM intervento i JOIN speaker s 
ON i.id_speaker = s.id_speaker JOIN ente e 
ON s.id_ente = e.id_ente
WHERE date_part('month',inizio) = mese AND date_part('year',inizio) = anno
group by e.nome;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\subsection{\texttt{Show\_percentage(INTEGER)}}
\begin{lstlisting}[language=SQL,style=mystyle]
CREATE OR REPLACE FUNCTION show_percentage_interventi(anno INTEGER)
RETURNS TABLE
(
nome varchar(7),
percentuale TEXT
) AS $$
DECLARE
totale INTEGER;
BEGIN
SELECT count(*) INTO totale
FROM intervento
WHERE date_part('year',inizio) = anno;

RETURN QUERY
SELECT e.nome, (count(*)*100/totale)::TEXT || '%'
FROM intervento i JOIN speaker s 
ON i.id_speaker = s.id_speaker JOIN ente e 
ON s.id_ente = e.id_ente
WHERE date_part('year',inizio) = anno
group by e.nome;
END;
$$ LANGUAGE PLPGSQL;
\end{lstlisting}
\section{Definizione delle viste}
\subsection{\texttt{SediView}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view SediView AS 
	SELECT s.nome AS Sede, 
	i.via ||', ' 
	|| i.civico
	|| ', ' 
	||  i.cap 
	||', ' 
	|| i.city 
	|| ' (' 
	|| i.provincia 
	||'), '
	|| i.nazione AS Indirizzo
	FROM sede s natural JOIN indirizzo i;
\end{lstlisting}
\subsection{\texttt{Conferenze\_Sede}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view conferenze_sede AS
	SELECT s.nome AS Sede, count(id_conferenza) AS Numero_Conferenze
	FROM sede s,conferenza c
	WHERE s.id_sede = c.id_sede
	group by s.nome;
\end{lstlisting}
\subsection{\texttt{Interventi\_Speaker}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view interventi_speaker AS
	SELECT s.nome || ' ' || s.cognome AS Speaker, count(i.id_intervento)
	FROM speaker s, intervento i 
	WHERE s.id_speaker = i.id_speaker
	group by s.nome,s.cognome;
\end{lstlisting}
\subsection{\texttt{Partecipanti\_Sessione}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view partecipanti_sessioni AS
	SELECT s.titolo AS Sessione, 
		count(p.id_partecipante) AS Numero_partecipanti
	FROM sessione s, partecipazione p 
	WHERE s.id_sessione = p.id_sessione
	group by s.titolo;
\end{lstlisting}
\subsection{\texttt{Partecipanti\_Conferenze}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view partecipanti_conferenze AS
	SELECT c.titolo AS Conferenza, 
		count(p.id_partecipante) AS Numero_partecipanti
	FROM conferenza c, sessione s, partecipazione p
	WHERE c.id_conferenza = s.id_conferenza 
	AND s.id_sessione = p.id_sessione
	group by c.titolo;
\end{lstlisting}
\subsection{\texttt{Sessioni}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view sessioni AS
	SELECT s.titolo AS Sessione,s.inizio,s.fine,c.titolo AS Conferenza,s1.nome FROM sessione s, conferenza c,sala s1
	WHERE s.id_conferenza=c.id_conferenza AND s.id_sala=s1.id_sala
	order by s.id_conferenza, s.inizio;
\end{lstlisting}