\chapter{Implementazione fisica}

\section{Definizione delle tabelle}
\lstinputlisting[language=SQL,style=mystyle,fontadjust]{Scripts/Tables.sql}
\section{Definizione dei trigger}
\subsection{\texttt{Check\_Programma}}
In un programma non devono esserci eventi, intervalli o interventi che si sovrappongono. Per questo motivo definiamo il trigger \texttt{check\_programma\_entry} che viene eseguito per ogni inserimento o aggiornamento nelle tabelle \textsc{Intervento}, \textsc{Intervallo} ed \textsc{Evento}.
\begin{lstlisting}[language=SQL,style=mystyle,caption={check\_programma\_entry}]
create or replace function check_programma() returns trigger as $$
declare
inizio_evento timestamp;
fine_evento timestamp;
inizio_intervallo timestamp;
fine_intervallo timestamp;
inizio_intervento timestamp;
fine_intervento timestamp;
intervento_id text;
intervallo_id text;
evento_id text;
interventi_cur cursor for select id_intervento from intervento where id_programma = new.id_programma;
intervalli_cur cursor for select id_intervallo from intervallo where id_programma = new.id_programma;
eventi_cur cursor for select id_evento from evento where id_programma = new.id_programma;
begin
open interventi_cur;
loop 
fetch interventi_cur into intervento_id;
exit when not found;
select inizio,fine into inizio_intervento,fine_intervento
from intervento
where id_intervento = intervento_id;
if (new.inizio>=inizio_intervento AND new.fine<=fine_intervento) then
raise exception 'Impossibile inserire questo intervento in questo orario';
end if;
end loop;
close interventi_cur;
open intervalli_cur;
loop 
fetch intervalli_cur into intervallo_id;
exit when not found;
select inizio,fine into inizio_intervallo,fine_intervallo
from intervallo
where id_intervallo = intervallo_id;
if (new.inizio>=inizio_intervallo AND new.fine<=fine_intervallo) then
raise exception 'Impossibile inserire questo intervallo in questo orario';
end if;
end loop;
close intervalli_cur;
open eventi_cur;
loop 
fetch eventi_cur into evento_id;
exit when not found;
select inizio,fine into inizio_evento,fine_evento
from evento
where id_evento = evento_id;
if (new.inizio>=inizio_evento AND new.fine<=fine_evento) then
raise exception 'Impossibile inserire questo evento in questo orario';
end if;
end loop;
close eventi_cur;
return new;
end;
$$ language plpgsql;
\end{lstlisting}

\subsection{\texttt{Check\_Data\_Intervento, Check\_Data\_Intervallo, Check\_Data\_Evento}}\label{trigger:check_data}
Ogni volta che viene inserito o aggiornato un intervento, un intervallo o un evento bisogna controllare sempre che la data di inizio e di fine sia coerente con quella della sessione cui appartengono:
\begin{lstlisting}[caption={check\_data\_intervento},language=SQL,style=mystyle]
create or replace function check_data() 
returns trigger as $$
declare
	inizio_sessione timestamp;
	fine_sessione timestamp;
begin
	select inizio,fine into inizio_sessione,fine_sessione
	from sessione
	where id_sessione = 
		(select id_sessione 
		from programma 
		where id_programma = new.id_programma);

	if (new.inizio < inizio_sessione OR new.fine > fine_sessione) then
		raise exception 'Gli orari non sono compatibili con quelli della sessione';
	end if;
	return new;
end;
$$ language plpgsql;

create trigger check_data_intervento
before insert or update on intervento
for each row
execute function check_data();

create trigger check_data_intervallo
before insert or update on intervallo
for each row
execute function check_data();

create trigger check_data_evento
before insert or update on evento
for each row
execute function check_data();
\end{lstlisting}
\subsection{\texttt{Create\_Programma\_Sessione}}
Il trigger \texttt{Create\_Programma\_Sessione} viene attivato subito dopo aver inserito una nuova sessione ed effettua l'inserimento di un programma vuoto associato alla sessione.
\begin{lstlisting}[language=SQL, caption={\texttt{create\_programma\_sessione}},style=mystyle]
	create or replace function create_programma_sessione() 
	returns trigger as $$
	begin
		insert into programma(id_sessione) values (new.id_sessione);
	return new;
	end;
	$$ language plpgsql;
	
	create trigger create_programma_sessione
	after insert on sessione
	for each row
	execute function create_programma_sessione();
\end{lstlisting}
\subsection{\texttt{Check\_Sala\_Sessione}}
Quando inseriamo una sessione bisogna stare attenti che la chiave esterna della sala sia effettivamente una sala appartenente alla sede che ospita la conferenza della sessione in questione. Il trigger \texttt{check\_sala\_sessione} effettua quindi questo controllo prima di ciascun inserimento nella tabella \textsc{Sessione}:
\begin{lstlisting}[language=SQL, style=mystyle]
	create or replace function check_sala_sessione() 
	returns trigger as $$
	declare
		sede integer;
		sala integer;
	begin
		select id_sede into sede
		from conferenza
		where id_conferenza = new.id_conferenza;
	
		select id_sala into sala
		from sala
		where id_sala = new.id_sala;
		
		if sala is null then -- Nulla da controllare
			return new;
		end if;
		
		IF sala NOT IN (
			SELECT id_sala
			FROM sala
			WHERE id_sede = sede
		) THEN
			RAISE EXCEPTION 'La sala selezionata non appartiene alla sede della conferenza';
		END IF;
		
		return new;
	end;
	$$ language plpgsql;
	
	
	create trigger check_sala_sessione
	before insert or update on sessione
	for each row
	execute function check_sala_sessione();
\end{lstlisting}
\subsection{\texttt{Check\_Data\_Sessione}}
Analogamente ai trigger \ref{trigger:check_data} si definisce il trigger \texttt{check\_data\_sessione} che controlla che le date di inizio e di fine di ciascuna sessione siano coerenti con quelle della relativa conferenza:
\begin{lstlisting}[language=SQL, style=mystyle, caption={\texttt{check\_data\_sessione}}]
	create or replace function check_data_sessione() 
	returns trigger as $$
	declare
		inizio_conferenza timestamp;
		fine_conferenza timestamp;
	begin
		select inizio, fine into inizio_conferenza,fine_conferenza
		from conferenza
		where id_conferenza = new.id_conferenza;
	
		if (new.inizio < inizio_conferenza OR new.fine > fine_conferenza) then
			raise exception 'Gli orari non sono compatibili con quelli della conferenza';
		end if;
		return new;
	end;
	$$ language plpgsql;
	
	create trigger check_data_sessione
	before insert or update on sessione
	for each row
	execute function check_data_sessione();
\end{lstlisting}
\subsection{\texttt{Check\_Coordinatore\_Sessione}}
Quando si specifica il coordinatore della sessione bisogna controllare che questi appartenga al comitato scientifico che è il gruppo di organizzatori che si occupano della gestione delle conferenze e delle sessioni:
\begin{lstlisting}[caption={check\_coordinatore\_sessione}, language=sql, style=mystyle]
create or replace function check_coordinatore_sessione() 
returns trigger as $$
declare 
id_comitato_scientifico_conferenza integer;
begin

select comitato_s into id_comitato_scientifico_conferenza
from conferenza c
where c.id_conferenza = new.id_conferenza;

if (new.id_coordinatore is not null) then
	if (id_comitato_scientifico_conferenza not in 
		(select id_comitato from organizzatore_comitato 
			where id_organizzatore = new.id_coordinatore))  then
			raise exception 'Il coordinatore della sessione deve appartenere al comitato scientifico della conferenza';
	end if;
end if;
return new;
end;
$$ language plpgsql;

create trigger check_coordinatore_sessione
before insert or update on sessione
for each row
execute function check_coordinatore_sessione();
\end{lstlisting}
\subsection{\texttt{Create\_Comitati\_Conferenza}}
Gli enti che organizzano le conferenze nominano due comitati per ogni conferenza che organizzano. Per questo motivo, ogni volta che viene inserita una nuova conferenza viene attivato il trigger \texttt{create\_comitati\_conferenza} che si occupa di creare due nuovi comitati di tipologica \textit{scientifica} e \textit{locale} e associarli alla nuova conferenza appena create:
\begin{lstlisting}[language=SQL, style=mystyle, caption={\texttt{create\_comitati\_conferenza}}]
create or replace function create_comitati_conferenza() 
returns trigger as $$
declare 
	id_comitatoscientifico integer;
	id_comitatolocale integer;
begin
	insert into comitato(tipologia) values ('scientifico') returning id_comitato into id_comitatoscientifico;
	insert into comitato(tipologia) values ('locale') returning id_comitato into id_comitatolocale;
	update conferenza 
	set comitato_s = id_comitatoscientifico, 
	comitato_l = id_comitatolocale 
	where id_conferenza = new.id_conferenza;
return new;
end;
$$ language plpgsql;

create trigger create_comitati_conferenza
after insert on conferenza
for each row
execute function create_comitati_conferenza();	
\end{lstlisting}
\subsection{\texttt{Check\_Comitati\_Conferenza}}
Ogni volta che si aggiorna una conferenza bisogna controllare che le chiavi esterne dei due comitati si riferiscano sempre a comitati della tipologia richiesta:
\begin{lstlisting}[language=SQL, caption={\texttt{check\_comitati\_conferenza}},style=mystyle]
	create or replace function check_comitati_conferenza() returns trigger as $$
	declare 
	id_comitato_scientifico integer;
	id_comitato_locale integer;
	begin
	select id_comitato into id_comitato_scientifico
	from comitato
	where id_comitato = new.comitato_s;
	
	select id_comitato into id_comitato_locale
	from comitato
	where id_comitato = new.comitato_l;
	
	IF id_comitato_scientifico IS NULL THEN
	return new;
	END IF;
	
	IF id_comitato_locale IS NULL THEN
	Return new;
	END IF;
	
	IF (select tipologia from comitato where id_comitato = id_comitato_scientifico) <> 'scientifico' THEN
	RAISE EXCEPTION 'Il comitato scientifico deve essere scientifico';
	END IF;
	
	IF (select tipologia from comitato where id_comitato = id_comitato_locale) <> 'locale' THEN
	RAISE EXCEPTION 'Il comitato locale deve essere locale';
	END IF;
	
	return new;
	end;
	$$ language plpgsql;
	
	create trigger check_comitati_conferenza
	before update on conferenza
	for each row
	execute function check_comitati_conferenza();
\end{lstlisting}
\subsection{\texttt{Check\_Sala\_Sessione\_Unica}}
Una sala non può ospitare più di una sessione alla volta.
\begin{lstlisting}[caption={\texttt{Check\_sala\_sessione\_unica}}, language=SQL, style=mystyle]
	create or replace function check_sala_sessione_unica() 
	returns trigger as $$
	declare
		inizio_sessione timestamp;
		fine_sessione timestamp;
		sessioni cursor for 
			select id_sessione 
			from sessione 
			where id_sala = new.id_sala;
		sessione_id integer;
	begin
	
	open sessioni;
	loop
		fetch sessioni into sessione_id;
		exit when not found;
		select inizio,fine into inizio_sessione,fine_sessione
		from sessione
		where id_sessione = sessione_id;
		if (new.inizio >= inizio_sessione AND new.inizio <= fine_sessione) 
		OR (new.fine >= inizio_sessione AND new.fine <= fine_sessione) then
			raise exception 'Impossibile ospitare due sessioni';
		end if;
	end loop;
	close sessioni;
	return new;
	end;
	$$ language plpgsql;
	
	create trigger check_sala_sessione_unica
	before insert or update on sessione
	for each row
	execute function check_sala_sessione_unica();
\end{lstlisting}
\subsection{\texttt{Check\_Organizzatore\_Comitato}}
Ogni volta che si inserisce un nuovo organizzatore all'interno di un comitato bisogna controllare che questo appartenga ad uno degli enti che organizzano la conferenza.
\begin{lstlisting}[language=SQL, style=mystyle, caption={\texttt{Check\_organizzatori\_comitato}}]
	create or replace function check_organizzatore_comitato() 
	returns trigger as $$
	declare
		ente_id integer;
	begin
	
	select id_ente into ente_id
	from organizzatore o
	where o.id_organizzatore = new.id_organizzatore;
	
	IF ente_id NOT IN (
		SELECT id_ente
		FROM ente_conferenza
		WHERE id_conferenza IN (
			SELECT id_conferenza
			FROM conferenza
			WHERE NEW.id_comitato 
			IN (id_comitato_scientifico, id_comitato_locale)
		)
	) THEN
		RAISE EXCEPTION 'L''organizzatore deve appartenere ad un ente che ha organizzato la conferenza';
	END IF;
	return new;
	end;
	$$ language plpgsql;
	
	create trigger check_organizzatore_comitato
	before insert or update on organizzatore_comitato
	for each row
	execute function check_organizzatore_comitato();
\end{lstlisting}
\subsection{\texttt{Delete\_Sessioni\_Conferenza}}
Nel caso in cui si volesse modificare la data di inizio o di fine di una conferenza vengono automaticamente cancellate le sessioni che si trovano escluse dal nuovo intervallo di date.
\begin{lstlisting}[language=SQL, style=mystyle, caption={\texttt{delete\_sessioni\_conferenza}}]
	create or replace function delete_sessioni_conferenza() 
	returns trigger as $$
	declare
	sessioni_cur cursor for 
		select id_sessione 
		from sessione 
		where id_conferenza = old.id_conferenza;
	sessione_id integer;
	begin
		open sessioni_cur;
		loop
			fetch sessioni_cur into sessione_id;
			exit when not found;
			if (select inizio
				from sessione 
				where id_sessione = sessione_id) < new.inizio 
			OR (select fine 
				from sessione 
				where id_sessione = sessione_id) > new.fine then
			delete from sessione where id_sessione = sessione_id;
			end if;
		end loop;
		close sessioni_cur;
		return new;
	end;
	$$ language plpgsql;
	
	create trigger delete_sessioni_conferenza
	before update on conferenza
	for each row
	execute function delete_sessioni_conferenza();
\end{lstlisting}
\subsection{\texttt{Check\_Capienza}}
Ogni volta che si aggiunge un nuovo partecipante della sessione bisogna controllare prima che la capienza della sala dove si svolge la sessione non sia stata raggiunta:
\begin{lstlisting}[language=SQL, style=mystyle]
	create or replace function check_capienza_sala() 
	returns trigger as $$
	declare
	capienza_s integer;
	partecipanti integer;
	begin
	select capienza into capienza_s
	from sala
	where id_sala = new.id_sala;
	
	select count(*) into partecipanti
	from partecipazione
	where id_sessione = new.id_sessione;
	
	if (partecipanti >= capienza_s) then
	raise exception 'La capienza della sala e'' stata raggiunta';
	end if;
	return new;
	end;
	$$ language plpgsql;
	
	create trigger check_capienza_sala
	before insert on partecipazione
	for each row
	execute function check_capienza_sala();
	
\end{lstlisting}
\section{Funzioni e procedure}
\subsection{\texttt{Show\_Conferenze\_By\_Date(date,date)}}
La funzione \texttt{Show\_Conferenze\_By\_Date} prende in ingresso due date e restituisce l'insieme di tutte le conferenze comprese tra queste:
\begin{lstlisting}[language=SQL, style=mystyle]
	create or replace function show_conference_by_date(dataI date, dataF date)
	returns setof conferenza as $$
	begin
	return query
	select * from conferenza
	where inizio >= start and fine <= dataF;
	end;
	$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_Conferenze\_By\_Sede(integer)}}
La funzione \texttt{Show\_Conferenze\_By\_Sede} prende in ingresso la chiave primaria di una sede e restituisce l'insieme di tutte le conferenze ospitate in quella determinata sede:
\begin{lstlisting}[language=SQL, style=mystyle]
create or replace function show_conferences_by_sede(sede int)
returns setof conferenza as $$
begin
return query
select * from conferenza
where id_sede = sede;
end;
$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_comitato\_scientifico(integer)}}
La funzione \texttt{Show\_comitato\_scientifico} prende in ingresso la chiave primaria di una conferenza e restituisce la lista di tutti i membri organizzatori appartenenti al comitato scientifico della conferenza:
\begin{lstlisting}[language=SQL, style=mystyle]
create or replace function 
show_comitato_scientifico(conferenza int)
returns setof organizzatore as $$
begin
return query
select * from organizzatore
where id_organizzatore in (
	select id_organizzatore 
	from organizzatore_comitato
	where id_comitato = (
		select id_comitato_scientifico 
		from conferenza
		where id_conferenza = conferenza));
end;
$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_comitato\_locale(integer)}}
La funzione \texttt{Show\_comitato\_locale} prende in ingresso la chiave primaria di una conferenza e restituisce la lista di tutti i membri organizzatori appartenenti al comitato locale della conferenza:
\begin{lstlisting}[language=SQL, style=mystyle]
create or replace function show_comitato_locale(conferenza int)
returns setof organizzatore as $$
begin
return query
select * from organizzatore
where id_organizzatore in (
	select id_organizzatore 
	from organizzatore_comitato
	where id_comitato = (
		select id_comitato_locale 
		from conferenza
		where id_conferenza = conferenza));
end;
$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_Partecipanti(integer)}}
La funzione \texttt{Show\_Partecipanti} prende in ingresso la chiave primaria di una conferenza e restituisce tutti i dettagli dei partecipanti di \textit{tutte le sessioni} della conferenza.
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace function show_partecipanti(conferenza int)
	returns setof partecipante as $$
	begin
	return query
	select * from partecipante
	where id_partecipante in (
		select id_partecipante 
		from partecipazione
		where id_sessione in (
			select id_sessione 
			from sessione
			where id_conferenza = conferenza));
	end;
	$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_Sessioni(integer)}}
La funzione \texttt{show\_sessioni} prende in ingresso la chiave primaria di una conferenza e restituisce tutti i dettagli delle sessioni.
\begin{lstlisting}[language=SQL, style=mystyle]
	create or replace function show_sessioni(conferenza int)
	returns setof sessione as $$
	begin
	return query
	select * from sessione
	where id_conferenza = conferenza
	order by inizio;
	end;
	$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_interventi\_sessione(integer)}}
La funzione \texttt{show\_interventi\_sessione} prende in ingresso la chiave primaria di una sessione e mostra tutti gli interventi presenti nel programma di tale sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace function 
	show_interventi_sessione(sessione int)
	returns table
	(
		titolo text,
		inizio timestamp,
		fine timestamp,
		abstract text,
		speaker text
	)  as $$
	declare 
		programma text;
	begin
		select id_programma into programma
		from programma
		where id_sessione = sessione;
	
		select titolo,inizio,fine,abstract, s.nome || ' ' || s.cognome as speaker
		from intervento i join speaker s on i.id_speaker = s.id_speaker
		where i.id_programma = programma
		order by inizio;
	end;
	$$ language plpgsql;
\end{lstlisting}

\subsection{\texttt{Show\_intervalli\_sessione(integer)}}
La funzione \texttt{show\_intervalli\_sessione} prende in ingresso la chiave primaria di una sessione e mostra tutti gli intervalli presenti nel programma di tale sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace function 
	show_intervalli_sessione(sessione int)
	returns table
	(
		tipologia intervallo_st,
		inizio timestamp,
		fine timestamp
	)  
	as $$
	declare 
	programma text;
	begin
	select id_programma into programma
	from programma
	where id_sessione = sessione;
	
	select tipologia,inizio,fine
	from intervallo i
	where id_programma = programma
	order by inizio;
	end;
	$$ 
	language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_eventi\_sociali\_sessione(integer)}}
La funzione \texttt{show\_eventi\_sociali\_sessione} prende in ingresso la chiave primaria di una sessione e mostra tutti gli intervalli presenti nel programma di tale sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace function 
show_eventi_sociali_sessione(sessione int)
returns table
(
	id_evento text,
	tipologia text,
	inizio timestamp,
	fine timestamp
) 
as $$
declare 
programma text;
begin
select id_programma into programma
from programma
where id_sessione = sessione;

select id_evento,tipologia,inizio,fine
from evento
where id_programma = programma
order by inizio;
end;
$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_keynote\_sessione(integer)}}
La funzione \texttt{show\_keynote\_sessione} prende in ingresso la chiave primaria di una sessione e mostra i dettagli del keynote speaker, se presente:
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace function show_keynote_sessione(sessione int)
returns table
(
	id_speaker text,
	nome text,
	cognome text,
	titolo text,
	email text,
	ente text
) 
as $$
declare
speaker_id text;
begin
select id_programma into programma
from programma
where id_sessione = sessione;

select id_keynote into speaker_id
from programma
where id_sessione = sessione;

if not found then
	raise notice 'Keynote non presente';
else
	select s.id_speaker,s.nome,s.cognome,s.titolo,s.email,e.nome
	from speaker s join ente e on s.id_ente = e.id_ente
	where s.id_speaker = speaker_id;
end if;
end;
$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_Programma(integer)}}
La funzione \texttt{Show\_Programma} prende in ingresso la chiave primaria di una sessione e restituisce una tabella che mostra tutti gli appuntamenti in progamma in ordine cronologico:
\begin{lstlisting}[language=SQL,style=mystyle]
	CREATE OR REPLACE FUNCTION 
	show_programma(sessione int)
	RETURNS TABLE 
	(
		id_entry text,
		appuntamento text,
		inizio timestamp,
		fine timestamp,
		descrizione text,
		speaker text
	)
	AS $$
	DECLARE
		programma text;
	BEGIN
	SELECT id_programma INTO programma
	FROM programma
	WHERE id_sessione = sessione;
	
	RETURN QUERY
	SELECT *
	FROM (
	SELECT distinct i.id_intervento AS id_entry,
	'intervento' AS appuntamento,
	i.inizio,
	i.fine,
	i.abstract,
	s.nome || ' ' || s.cognome AS speaker
	FROM intervento i
	JOIN speaker s ON i.id_speaker = s.id_speaker
	WHERE i.id_programma = programma
	
	UNION ALL
	
	SELECT i2.id_intervallo AS id_entry,
	'intervallo' AS appuntamento,
	i2.inizio,
	i2.fine,
	tipologia::text as descrizione,
	NULL
	FROM intervallo i2
	WHERE i2.id_programma = programma
	
	UNION ALL
	
	SELECT e.id_evento AS id_entry,
	'evento' AS appuntamento,
	e.inizio,
	e.fine,
	e.tipologia::text AS descrizione,
	NULL
	FROM evento e
	WHERE e.id_programma = programma
	) AS subquery
	ORDER BY inizio;
	END;
	$$
	LANGUAGE plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Intervento(text,text,text,int,interval)}}
La procedura \texttt{Add\_intervento} provvede all'inserimento di un intervento all'interno del programma della sessione. Questa calcola l'orario esatto in cui inserire il nuovo punto sulla base dell'ultimo punto in programma. Se non esistono punti in programma allora l'ora di inizio è calcolato come l'inizio della sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace procedure add_intervento
(titolo text, abstract text, speaker text, sessione_id int, durata interval)
as $$
declare
programma text;
id text;
query text;
category text;
fine_prev timestamp;
begin
select id_programma into programma
from programma
where id_sessione = sessione_id;

select max(fine) into fine_prev
from show_programma(sessione_id);

if (fine_prev is null) then
select inizio into fine_prev
from sessione
where id_sessione = sessione_id;
end if;

insert into intervento(titolo,abstract,id_speaker,id_programma,inizio,fine)
values (titolo,abstract,speaker,programma,fine_prev,fine_prev+durata);
raise notice 'Inserimento completato';
exception
when others then
raise notice '%', sqlerrm;
end;
\end{lstlisting}
\subsection{\texttt{Add\_Intervallo(text,int,interval)}}
La procedura \texttt{Add\_Intervallo} provvede all'inserimento di un intervallo all'interno del programma della sessione. Questa calcola l'orario esatto in cui inserire il nuovo punto sulla base dell'ultimo punto in programma. Se non esistono punti in programma allora l'ora di inizio è calcolato come l'inizio della sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace procedure 
add_intervallo(tipologia text , sessione_id int, durata interval)
as $$
declare
programma text;
id text;
query text;
category text;
fine_prev timestamp;
begin
select id_programma into programma
from programma
where id_sessione = sessione_id;

select max(fine) into fine_prev
from show_programma(sessione_id);

if (fine_prev is null) then
select inizio into fine_prev
from sessione
where id_sessione = sessione_id;
end if;

insert into intervallo(tipologia,id_programma,inizio,fine)
values (tipologia::intervallo_st, programma, fine_prev, fine_prev+durata);
raise notice 'Inserimento completato';
exception
when others then
raise notice '%', sqlerrm;
end;
$$ 
language plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Evento(text,int,interval)}}
La procedura \texttt{Add\_Evento} provvede all'inserimento di un evento all'interno del programma della sessione. Questa calcola l'orario esatto in cui inserire il nuovo punto sulla base dell'ultimo punto in programma. Se non esistono punti in programma allora l'ora di inizio è calcolato come l'inizio della sessione:
\begin{lstlisting}[language=SQL,style=mystyle]
create or replace procedure 
add_evento (tipologia text, sessione_id int, durata interval)
as $$
declare
programma_id text;
id text;
query text;
category text;
fine_prev timestamp;
begin

select id_programma into programma_id
from programma
where id_sessione = sessione_id;

select max(fine) into fine_prev
from show_programma(sessione_id);

if (fine_prev is null) then
select inizio into fine_prev
from sessione
where id_sessione = sessione_id;
end if;

insert into evento(tipologia, id_programma, inizio, fine)
values (tipologia, programma_id, fine_prev, fine_prev+durata);
raise notice 'Inserimento completato';
exception
when others then
raise notice '%', sqlerrm;
end;
$$
language plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Conferenza\_Details(text,timestamp,timestamp,integer,text)}}
La funzione \texttt{Add\_Conferenza\_Details} aggiunge una conferenza e restituisce la chiave primaria della nuova conferenza.
\begin{lstlisting}[language=SQL,style=mystyle]
	CREATE OR REPLACE FUNCTION add_conferenza_details(nome text, inizio timestamp, fine timestamp, sede integer, abstract text)
	RETURNS integer AS $$
	DECLARE
	id integer;
	BEGIN
	INSERT INTO conferenza(titolo, inizio, fine, id_sede, descrizione) 
	VALUES (nome, inizio, fine, sede, abstract)
	RETURNING id_conferenza INTO id;
	raise notice 'Inserimento completato';
	RETURN id;
	EXCEPTION
	WHEN OTHERS THEN
	RAISE NOTICE 'Errore nell''inserimento di una conferenza: %', SQLERRM;
	RETURN 0; 
	END;
	$$ 
	language plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_ente(integer, integer)}}
La procedura \texttt{Add\_ente} provvede all'inserimento di una nuova istituzione tra gli organizzatori di una conferenza.
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace procedure 
	add_ente(ente text, conferenza integer)
	as $$
	begin
	insert into ente_conferenza(id_ente,id_conferenza)
	values (ente,conferenza);
	raise notice 'Inserimento completato';
	exception
	when others then
	raise notice '%', sqlerrm;
	end;
	$$ 
	language plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Sponsorizzazione(integer,numeric,char(3),integer)}}
La procedura \texttt{Add\_Sponsorizzazione} inserisce una nuova sponsorizzazione per la conferenza:
\begin{lstlisting}[language=SQL, style=mystyle]
	create or replace procedure 
	add_sponsorizzazione(sponsor integer, contributo numeric(1000,2), valuta char(3), conferenza integer)
	as $$
	begin
	insert into sponsorizzazione(id_sponsor,contributo,valuta,id_conferenza)
	values (sponsor,contributo,valuta,conferenza);
	raise notice 'Inserimento completato';
	exception
	when others then
	raise notice '%', sqlerrm;
	end;
	$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Sessione(text,timestamp,timestamp, integer,integer)}}
La procedura \texttt{Add\_Sessione} aggiunge una nuova sessione per la conferenza:
\begin{lstlisting}[language=SQL, style=mystyle]
	create or replace procedure 
	add_sessione(titolo text, inizio timestamp, fine timestamp, sala integer, conferenza integer)
	as $$
	begin
	insert into sessione(titolo,inizio,fine,id_sala,id_conferenza)
	values (titolo,inizio,fine,sala,conferenza);
	raise notice 'Inserimento completato';
	exception
	when others then
	raise notice '%', sqlerrm;
	end;
	$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Partecipante(integer, integer)}}
La procedura \texttt{Add\_Partecipante} inserisce un nuovo partecipante alla sessione:
\begin{lstlisting}[language=SQL, style=mystyle]
	create or replace procedure 
	add_partecipante(partecipante integer, sessione integer)
	as $$
	begin
		insert into partecipante_sessione(id_partecipante,id_sessione)
		values (partecipante,sessione);
	raise notice 'Inserimento completato';
	exception
		when others then
			raise notice '%', sqlerrm;
	end;
	$$ 
	language plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Enti(integer,text)}}
\begin{lstlisting}[language=SQL,style=mystyle]
	CREATE OR REPLACE PROCEDURE 
	add_enti(conferenza integer, sigle text)
	AS $$
	DECLARE
	sigla_ente text;
	ente_id integer;
	BEGIN
	FOR sigla_ente IN SELECT unnest(string_to_array(sigle, ',')) LOOP
	SELECT id_ente INTO ente_id FROM ente WHERE sigla = sigla_ente;

	INSERT INTO ente_conferenza(id_ente, id_conferenza) VALUES (ente_id, conferenza);
	END LOOP;
	RAISE NOTICE 'Inserimento completato';
	
	EXCEPTION
	WHEN OTHERS THEN
	RAISE EXCEPTION 'Errore durante l''inserimento delle tuple nella tabella ente_conferenza: %', SQLERRM;
	END;
	$$ LANGUAGE plpgsql;
\end{lstlisting}
\subsection{\texttt{Add\_Conferenza(text,timestamp,timestamp,integer, text, text)}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace procedure 
	add_conferenza(nome text, inizio timestamp, fine timestamp, sede integer, descrizione text, sigle text)
	as $$
	declare
	id_conferenza int;
	begin
	id_conferenza := add_conferenza_details(nome,inizio,fine,sede,descrizione);
	call add_enti(id_conferenza,sigle);
	exception
	when others then
	raise notice '%', sqlerrm;
	end;
	$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Slitta\_Conferenza(interval)}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace procedure 
slitta_conferenza(conferenza_id integer, durata interval)
as $$
declare
sessione_id integer;
intervento_id text;
evento_id text;
intervallo_id text;
sessioni cursor for 
select id_sessione 
from sessione 
where id_conferenza = conferenza_id;

interventi cursor for
select id_intervento 
from intervento i join programma p 
on i.id_programma = p.id_programma 
where p.id_sessione in 
(select id_sessione 
from sessione 
where id_conferenza = conferenza_id);

intervalli cursor for
select id_intervallo 
from intervallo i join programma p 
on i.id_programma = p.id_programma 
where p.id_sessione in 
(select id_sessione 
from sessione 
where id_conferenza = conferenza_id);

eventi cursor for
select id_evento 
from evento e join programma p 
on e.id_programma = p.id_programma 
where p.id_sessione in 
(select id_sessione 
from sessione 
where id_conferenza = conferenza_id);
begin
alter table conferenza disable trigger all;
alter table sessione disable trigger all;
alter table intervento disable trigger all;
alter table intervallo disable trigger all;
alter table evento disable trigger all;
alter table programma disable trigger all;
update conferenza
set inizio = inizio + durata, fine = fine + durata
where id_conferenza = conferenza_id;

open sessioni;
loop
fetch sessioni into sessione_id;
exit when not found;

update sessione
set inizio = inizio + durata, fine = fine + durata
where id_sessione = sessione_id;

open interventi;
loop
fetch interventi into intervento_id;
exit when not found;

update intervento
set inizio = inizio + durata, fine = fine + durata
where id_intervento = intervento_id ;
end loop;
close interventi;

open intervalli;
loop
fetch intervalli into intervallo_id;
exit when not found;

update intervallo
set inizio = inizio + durata, fine = fine + durata
where id_intervallo = intervallo_id;
end loop;
close intervalli;

open eventi;
loop
fetch eventi into evento_id;
exit when not found;

update evento
set inizio = inizio + durata, fine = fine + durata
where id_evento = evento_id;
end loop;
close eventi;
end loop;
close sessioni;
alter table conferenza enable trigger all;
alter table sessione enable trigger all;
alter table intervento enable trigger all;
alter table intervallo enable trigger all;
alter table evento enable trigger all;
alter table programma enable trigger all;
raise notice 'Slittamento completato';
exception
when others then
raise notice '%', sqlerrm;
end;
$$ language plpgsql;
\end{lstlisting}

\subsection{\texttt{Show\_members()}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace function 
	show_members(conferenza integer)
	returns table 
	(
	id integer, 
	nome text, 
	cognome text, 
	email text,
	titolo titolo_st, 
	sigla varchar(7)
	) as $$
	begin
	return query
	select o.id_organizzatore, o.nome, o.cognome, o.email,o.titolo, e.sigla
	from organizzatore o join ente_conferenza ec natural join ente e  
	on o.id_ente = ec.id_ente
	where ec.id_conferenza = conferenza
	GROUP by e.sigla;
	end;
	$$ language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_percentage\_interventi}(int,int)}
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace function 
	show_percentage_interventi(mese int, anno int)
	returns table
	(
		sigla varchar(7),
		percentuale text
	) as $$
	declare
	totale int;
	begin
	select count(*) into totale
	from intervento
	where date_part('month',inizio) = mese and date_part('year',inizio) = anno;
	
	return query
	select e.sigla, (count(*)*100/totale)::text || '%'
	from intervento i join speaker s 
	on i.id_speaker = s.id_speaker join ente e 
	on s.id_ente = e.id_ente
	where date_part('month',inizio) = mese and date_part('year',inizio) = anno
	group by e.sigla;
	end;
	$$ 
	language plpgsql;
\end{lstlisting}
\subsection{\texttt{Show\_percentage(int)}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create or replace function 
	show_percentage_interventi(anno int)
	returns table
	(
		sigla varchar(7),
		percentuale text
	) as $$
	declare
	totale int;
	begin
	select count(*) into totale
	from intervento
	where date_part('year',inizio) = anno;
	
	return query
	select e.sigla, (count(*)*100/totale)::text || '%'
	from intervento i join speaker s 
	on i.id_speaker = s.id_speaker join ente e 
	on s.id_ente = e.id_ente
	where date_part('year',inizio) = anno
	group by e.sigla;
	end;
	$$ 
	language plpgsql;
\end{lstlisting}
\section{Definizione delle viste}
\subsection{\texttt{SediView}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view SediView as 
	select s.nome as Sede, 
	i.via ||', ' 
	|| i.civico
	|| ', ' 
	||  i.cap 
	||', ' 
	|| i.city 
	|| ' (' 
	|| i.provincia 
	||'), '
	|| i.nazione as Indirizzo
	from sede s natural join indirizzo i;
\end{lstlisting}
\subsection{\texttt{Conferenze\_Sede}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view conferenze_sede as
	select s.nome as Sede, count(id_conferenza) as Numero_Conferenze
	from sede s,conferenza c
	where s.id_sede = c.id_sede
	group by s.nome;
\end{lstlisting}
\subsection{\texttt{Interventi\_Speaker}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view interventi_speaker as
	select s.nome || ' ' || s.cognome as Speaker, count(i.id_intervento)
	from speaker s, intervento i 
	where s.id_speaker = i.id_speaker
	group by s.nome,s.cognome;
\end{lstlisting}
\subsection{\texttt{Partecipanti\_Sessione}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view partecipanti_sessioni as
	select s.titolo as Sessione, 
		count(p.id_partecipante) as Numero_partecipanti
	from sessione s, partecipazione p 
	where s.id_sessione = p.id_sessione
	group by s.titolo;
\end{lstlisting}
\subsection{\texttt{Partecipanti\_Conferenze}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view partecipanti_conferenze as
	select c.titolo as Conferenza, 
		count(p.id_partecipante) as Numero_partecipanti
	from conferenza c, sessione s, partecipazione p
	where c.id_conferenza = s.id_conferenza 
	and s.id_sessione = p.id_sessione
	group by c.titolo;
\end{lstlisting}
\subsection{\texttt{Sessioni}}
\begin{lstlisting}[language=SQL,style=mystyle]
	create view sessioni as
	select s.titolo as Sessione,s.inizio,s.fine,c.titolo as Conferenza,s1.nome from sessione s, conferenza c,sala s1
	where s.id_conferenza=c.id_conferenza and s.id_sala=s1.id_sala
	order by s.id_conferenza, s.inizio;
\end{lstlisting}